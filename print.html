<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Rust By Example -- Extended Edition</title>
        <meta name="robots" content="noindex" />
        <!-- Custom HTML head -->
        

        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="Covers popular third party Rust crates and libraries by example">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">
        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item affix "><a href="index.html">Introduction</a></li><li class="chapter-item "><a href="serde.html"><strong aria-hidden="true">1.</strong> Serialization</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="serde/json.html"><strong aria-hidden="true">1.1.</strong> JSON</a></li><li class="chapter-item "><a href="serde/bincode.html"><strong aria-hidden="true">1.2.</strong> Binary</a></li><li class="chapter-item "><a href="serde/feature.html"><strong aria-hidden="true">1.3.</strong> Third party crates</a></li></ol></li><li class="chapter-item "><a href="rand.html"><strong aria-hidden="true">2.</strong> Random numbers</a></li><li class="chapter-item "><a href="openssl.html"><strong aria-hidden="true">3.</strong> SSL/TLS toolkit</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="openssl/rsa.html"><strong aria-hidden="true">3.1.</strong> RSA</a></li></ol></li><li class="chapter-item "><a href="ndarray.html"><strong aria-hidden="true">4.</strong> N-dimensional array</a></li><li class="chapter-item "><a href="lazy_static.html"><strong aria-hidden="true">5.</strong> Lazy initialization</a></li><li class="chapter-item "><a href="regex.html"><strong aria-hidden="true">6.</strong> Regular expression</a></li><li class="chapter-item "><a href="webassembly.html"><strong aria-hidden="true">7.</strong> WebAssembly</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="webassembly/compile.html"><strong aria-hidden="true">7.1.</strong> Compile targets</a></li><li class="chapter-item "><a href="webassembly/run.html"><strong aria-hidden="true">7.2.</strong> Run a simple program</a></li><li class="chapter-item "><a href="webassembly/browser.html"><strong aria-hidden="true">7.3.</strong> Rust Javascript binding</a></li><li class="chapter-item "><a href="webassembly/nodejs.html"><strong aria-hidden="true">7.4.</strong> WebAssembly on the server side</a></li><li class="chapter-item "><a href="webassembly/nodejshelper.html"><strong aria-hidden="true">7.5.</strong> Call Javascript from Rust</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Rust By Example -- Extended Edition</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/second-state/rust-by-example-ext" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="rust-by-example----extended-edition"><a class="header" href="#rust-by-example----extended-edition">Rust by Example -- Extended Edition</a></h1>
<p><a href="https://www.rust-lang.org/">Rust</a> is a modern systems programming language focusing on safety, speed,
and concurrency. It accomplishes these goals by being memory safe without using 
garbage collection. A big part of Rust's strength and success comes from the
large ecosystem of third party libraries, known as crates.</p>
<p>Rust by Example -- Extended Edition (RBEext) is a collection of runnable examples that illustrate how to use popular Rust
third party libraries and crates. It is designed to complement the official 
<a href="https://doc.rust-lang.org/rust-by-example/">Rust by Example (RBE)</a> book that focuses on the 
core language and standard libraries.
Additionally for the curious, you can also <a href="https://github.com/second-state/rust-by-example-ext">check out the source code for this site</a>.</p>
<blockquote>
<p><strong>Note:</strong> Many examples in this book are directly runnable from the web page. See the animation below this note. However, the <a href="https://play.rust-lang.org/">Rust playground</a> only supports <a href="https://github.com/integer32llc/rust-playground/blob/master/compiler/base/Cargo.toml">100</a> 3rd party crates. For crates or features that are not supported by the playground, we show the results next to the examples, and link to <a href="https://github.com/second-state/rust-by-example-ext/tree/master/examples/">cargo project source code</a>.</p>
</blockquote>
<p><img src="rbeext.gif" alt="Run an example from the web page" /></p>
<p>Now let's begin!</p>
<ul>
<li>
<p><a href="serde.html">Serialization</a> - Serialization and deserialization are key to data exchange between Rust programs and the rest of the world. The <code>serde</code> crate is the de facto standard here.</p>
</li>
<li>
<p><a href="rand.html">Random numbers</a> - It is surprisingly difficult to get high quality random numbers for your application. The <code>rand</code> crate can help.</p>
</li>
<li>
<p><a href="openssl.html">SSL/TLS toolkit</a> - Rust API wrappers for the OpenSSL library to handle public key infrastructure and secure communications. Encryption, decryption, digital certificates, digital signature, secure digest, secure network protocols, and more!</p>
</li>
<li>
<p><a href="ndarray.html">N-dimensional array</a> - Multi-dimensional arrays are crucial for scientific computing, data mining, machine learning (ML), and artificial intelligence (AI) applications.</p>
</li>
<li>
<p><a href="lazy_static.html">Lazy initialization</a> - Lazy initialization allows you to assign values to static variables at runtime.</p>
</li>
<li>
<p><a href="regex.html">Regular expression</a> - Processing and manipulating text and string values.</p>
</li>
<li>
<p><a href="webassembly.html">WebAssembly</a> - It is very popular to run Rust apps in WebAssembly, learn why and how.</p>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="serialization-and-deserialization"><a class="header" href="#serialization-and-deserialization">Serialization and deserialization</a></h1>
<p>Serialization is a core language feature in the era of web applications. When one program needs to talk to another program
over the Internet, it needs to serialize its data into a format that can be transmitted through the network. The receiving
program uses deserialization to reconstruct the data.</p>
<p>In Rust, most applications use the <a href="https://crates.io/crates/serde"><code>serde</code></a> crate to manage serialization and deserialization. In this chapter, we will cover how to serialize typed Rust data into <a href="serde/json.html">JSON strings</a> 
or <a href="serde/bincode.html">byte arrays</a>. We will also discuss how to serialize third party structs in libraries.</p>
<p>Checkout the <a href="https://serde.rs/">official documentation</a> for the <code>serde</code> crate.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="serialize-into-json-strings"><a class="header" href="#serialize-into-json-strings">Serialize into JSON strings</a></h1>
<p>To use the <code>serde</code> crate, you just need to add the following dependencies to your <code>Cargo.toml</code> file.</p>
<pre><code>[dependencies]
serde = { version = &quot;1.0&quot;, features = [&quot;derive&quot;] }
serde_json = &quot;1.0&quot;
</code></pre>
<p>The example below shows how to serialize a simple Rust primitive data type <code>i32</code> into a JSON string, and then deserialize it back. Run it! You can pass this JSON string to other Rust programs or Internet applications written in other languages.</p>
<pre><pre class="playground"><code class="language-rust editable"><span class="boring">extern crate serde;
</span>
fn main() {
    let x: i32 = 5;
    let xs = serde_json::to_string(&amp;x).unwrap();
    println!(&quot;i32 number {} serializes into string {}&quot;, x, xs);
    let xd: i32 = serde_json::from_str(&amp;xs).unwrap();
    assert_eq!(x, xd);
}
</code></pre></pre>
<p>Here are more examples showing the serialization and deserialization of Rust primitive data types. Rust arrays and tuples are all serialized to JSON arrays. Edit the code below to try more Rust types, and run it to see the results.</p>
<pre><pre class="playground"><code class="language-rust editable"><span class="boring">extern crate serde;
</span>
fn main() {
    let x: i32 = 5;
    let xs = serde_json::to_string(&amp;x).unwrap();
    println!(&quot;i32 number {} serializes into string {}&quot;, x, xs);
    let xd: i32 = serde_json::from_str(&amp;xs).unwrap();
    assert_eq!(x, xd);

    let x: f32 = 3.14;
    let xs = serde_json::to_string(&amp;x).unwrap();
    println!(&quot;f32 number {} serializes into string {}&quot;, x, xs);

    let x: Vec&lt;u8&gt; = vec![1, 2, 3];
    let xs = serde_json::to_string(&amp;x).unwrap();
    println!(&quot;Vec&lt;u8&gt; {:?} serializes into string {}&quot;, x, xs);
    let xd: Vec&lt;u8&gt; = serde_json::from_str(&amp;xs).unwrap();
    assert_eq!(x, xd);

    let x: Vec&lt;f32&gt; = vec![3.141, 2.718, 1.618];
    let xs = serde_json::to_string(&amp;x).unwrap();
    println!(&quot;Vec&lt;f32&gt; {:?} serializes into string {}&quot;, x, xs);
    
    let x: (i32, &amp;str, f32, bool) = (1, &quot;hello&quot;, 4.5, true);
    let xs = serde_json::to_string(&amp;x).unwrap();
    println!(&quot;tuple {:?} serializes into string {}&quot;, x, xs);
    let xd: (i32, &amp;str, f32, bool) = serde_json::from_str(&amp;xs).unwrap();
    assert_eq!(x, xd);

    let x = ((1u8, 2u16), (3.141f32, 'a'), true);
    let xs = serde_json::to_string(&amp;x).unwrap();
    println!(&quot;nested tuple {:?} serializes into string {}&quot;, x, xs);
}
</code></pre></pre>
<p>What about structs and other custom Rust data types? Well, you just need to annotate them and they will automagically get serialization capabilities! Run the example below and you can see the JSON string representation of these Rust structs.</p>
<pre><pre class="playground"><code class="language-rust editable"><span class="boring">extern crate serde;
</span>
use serde::{Serialize, Deserialize};

#[derive(Serialize, Deserialize, Debug)]
struct Point {
  x: f32,
  y: f32
}

#[derive(Serialize, Deserialize, Debug)]
struct Line {
  points: Vec&lt;Point&gt;,
  valid: bool,
  length: f32,
  desc: String
}

fn main() {
    let point1: Point = Point {x:1.0, y:2.0};
    let point2: Point = Point {x:3.0, y:4.0};
    let point1s = serde_json::to_string(&amp;point1).unwrap();
    let point2s = serde_json::to_string(&amp;point2).unwrap();
    println!(&quot;struct Point serializes into string {}&quot;, point1s);
    println!(&quot;struct Point serializes into string {}&quot;, point2s);

    let length = ((point1.x - point2.x) * (point1.x - point2.x) + (point1.y - point2.y) * (point1.y - point2.y)).sqrt();
    let valid = if length == 0.0 { false } else { true };
    let line = Line { points: vec![point1, point2], valid: valid, length: length, desc: &quot;a thin line&quot;.to_string() };
    let lines = serde_json::to_string(&amp;line).unwrap();
    println!(&quot;struct Line serializes into string {}&quot;, lines);

    let lined: Line = serde_json::from_str(&amp;lines).unwrap();
    assert_eq!(lined.desc, &quot;a thin line&quot;);
    assert_eq!(lined.points[1].x, 3.0);
}
</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="serialize-into-binary"><a class="header" href="#serialize-into-binary">Serialize into binary</a></h1>
<p>JSON strings are portable across almost all programming languages and frameworks. But for communication between Rust programs, a binary format could be much more efficient. Here is where <code>bincode</code> comes into play. To use the <code>bincode</code> crate, you just need to add the following dependencies to your <code>Cargo.toml</code> file.</p>
<pre><code>[dependencies]
serde = { version = &quot;1.0&quot;, features = [&quot;derive&quot;] }
bincode = &quot;1.2.1&quot;
</code></pre>
<blockquote>
<p><strong>Note:</strong> Since the <code>bincode</code> crate is not included the Rust Playground by default, the code examples in this article are not interactive. We will show the program output in the text. You can run these examples from <a href="https://github.com/second-state/rust-by-example-ext/tree/master/examples/serde/bincode">this cargo project</a>.</p>
</blockquote>
<p>The example below shows how to serialize a simple Rust primitive data type <code>i32</code> into a byte array, and then deserialize it back. You can pass this byte array to other Rust programs over the Internet.</p>
<pre><code class="language-rust noplaypen">use bincode;

fn main() {
    let x: i32 = 5;
    let xs: Vec&lt;u8&gt; = bincode::serialize(&amp;x).unwrap();
    println!(&quot;i32 number {} serializes into byte array {:?}&quot;, x, xs);
    let xd: i32 = bincode::deserialize(&amp;xs).unwrap();
    assert_eq!(x, xd);
}
</code></pre>
<p>Result</p>
<pre><code>i32 number 5 serializes into byte array [5, 0, 0, 0]
</code></pre>
<p>Here are more examples showing the serialization and deserialization of Rust primitive data types. Edit the code below to try more Rust types, and run it to see the results.</p>
<pre><code class="language-rust noplaypen">use bincode;

fn main() {
    let x: i32 = 5;
    let xs: Vec&lt;u8&gt; = bincode::serialize(&amp;x).unwrap();
    println!(&quot;i32 number {} serializes into byte array {:?}&quot;, x, xs);
    let xd: i32 = bincode::deserialize(&amp;xs).unwrap();
    assert_eq!(x, xd);

    let x: f32 = 3.14;
    let xs = bincode::serialize(&amp;x).unwrap();
    println!(&quot;f32 number {} serializes into byte array {:?}&quot;, x, xs);

    let x: Vec&lt;u8&gt; = vec![1, 2, 3];
    let xs = bincode::serialize(&amp;x).unwrap();
    println!(&quot;Vec&lt;u8&gt; {:?} serializes into byte array {:?}&quot;, x, xs);
    let xd: Vec&lt;u8&gt; = bincode::deserialize(&amp;xs).unwrap();
    assert_eq!(x, xd);

    let x: Vec&lt;f32&gt; = vec![3.141, 2.718, 1.618];
    let xs = bincode::serialize(&amp;x).unwrap();
    println!(&quot;Vec&lt;f32&gt; {:?} serializes into byte array {:?}&quot;, x, xs);
    let xd: Vec&lt;f32&gt; = bincode::deserialize(&amp;xs).unwrap();
    assert_eq!(x, xd);

    let x: (i32, &amp;str, f32, bool) = (1, &quot;hello&quot;, 4.5, true);
    let xs = bincode::serialize(&amp;x).unwrap();
    println!(&quot;tuple {:?} serializes into byte array {:?}&quot;, x, xs);
    let xd: (i32, &amp;str, f32, bool) = bincode::deserialize(&amp;xs).unwrap();
    assert_eq!(x, xd);

    let x = ((1u8, 2u16), (3.141f32, 'a'), true);
    let xs = bincode::serialize(&amp;x).unwrap();
    println!(&quot;nested tuple {:?} serializes into byte array {:?}&quot;, x, xs);
}
</code></pre>
<p>Result</p>
<pre><code>i32 number 5 serializes into byte array [5, 0, 0, 0]
f32 number 3.14 serializes into byte array [195, 245, 72, 64]
Vec&lt;u8&gt; [1, 2, 3] serializes into byte array [3, 0, 0, 0, 0, 0, 0, 0, 1, 2, 3]
Vec&lt;f32&gt; [3.141, 2.718, 1.618] serializes into byte array [3, 0, 0, 0, 0, 0, 0, 0, 37, 6, 73, 64, 182, 243, 45, 64, 160, 26, 207, 63]
tuple (1, &quot;hello&quot;, 4.5, true) serializes into byte array [1, 0, 0, 0, 5, 0, 0, 0, 0, 0, 0, 0, 104, 101, 108, 108, 111, 0, 0, 144, 64, 1]
nested tuple ((1, 2), (3.141, 'a'), true) serializes into byte array [1, 2, 0, 37, 6, 73, 64, 97, 1]
</code></pre>
<p>What about structs and other custom Rust data types? Well, you just need to annotate them with <code>serde</code> and they will automagically get serialization capabilities!</p>
<pre><code class="language-rust noplaypen">use serde::{Serialize, Deserialize};
use bincode;

#[derive(Serialize, Deserialize, Debug)]
struct Point {
  x: f32,
  y: f32
}

#[derive(Serialize, Deserialize, Debug)]
struct Line {
  points: Vec&lt;Point&gt;,
  valid: bool,
  length: f32,
  desc: String
}

fn main() {
    let point1: Point = Point {x:1.0, y:2.0};
    let point2: Point = Point {x:3.0, y:4.0};
    let point1s = bincode::serialize(&amp;point1).unwrap();
    let point2s = bincode::serialize(&amp;point2).unwrap();
    println!(&quot;struct Point serializes into byte array {:?}&quot;, point1s);
    println!(&quot;struct Point serializes into byte array {:?}&quot;, point2s);

    let length = ((point1.x - point2.x) * (point1.x - point2.x) + (point1.y - point2.y) * (point1.y - point2.y)).sqrt();
    let valid = if length == 0.0 { false } else { true };
    let line = Line { points: vec![point1, point2], valid: valid, length: length, desc: &quot;a thin line&quot;.to_string() };
    let lines = bincode::serialize(&amp;line).unwrap();
    println!(&quot;struct Line serializes into byte array {:?}&quot;, lines);

    let lined: Line = bincode::deserialize(&amp;lines).unwrap();
    assert_eq!(lined.desc, &quot;a thin line&quot;);
    assert_eq!(lined.points[1].x, 3.0);
}
</code></pre>
<p>Result</p>
<pre><code>struct Point serializes into byte array [0, 0, 128, 63, 0, 0, 0, 64]
struct Point serializes into byte array [0, 0, 64, 64, 0, 0, 128, 64]
struct Line serializes into byte array [2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 128, 63, 0, 0, 0, 64, 0, 0, 64, 64, 0, 0, 128, 64, 1, 243, 4, 53, 64, 11, 0, 0, 0, 0, 0, 0, 0, 97, 32, 116, 104, 105, 110, 32, 108, 105, 110, 101]
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="serialize-third-party-library-types"><a class="header" href="#serialize-third-party-library-types">Serialize third party library types</a></h1>
<p>Many third party Rust crates already support serialization and deserialization
via the <code>serde</code> crate. You just need to enable the <code>serde</code> feature when you 
declare the crate as dependency.</p>
<pre><code>[dependencies]
serde = { version = &quot;1.0&quot;, features = [&quot;derive&quot;] }
serde_json = &quot;1.0&quot;
num-bigint = { version = &quot;0.2&quot;, features = [&quot;serde&quot;] }
num = &quot;0.2&quot;
</code></pre>
<blockquote>
<p><strong>Note:</strong> Since the <code>serde</code> feature is not enabled on third party crates in the Rust Playground by default, the code examples in this article are not interactive. We will show the program output in the text. You can run these examples from <a href="https://github.com/second-state/rust-by-example-ext/tree/master/examples/serde/feature">this cargo project</a>.</p>
</blockquote>
<p>The example below shows how to serialize and deserialize a <code>BigInt</code> struct type from the <code>num_bigint</code> crate. It just works out of the box.</p>
<pre><code class="language-rust noplaypen">use num::bigint::ToBigInt;
use num_bigint::BigInt;

fn main() {
    let a = 3.to_bigint().unwrap();
    let x = num::pow(a, 247);
    let xs = serde_json::to_string(&amp;x).unwrap();
    let xd: BigInt = serde_json::from_str(&amp;xs).unwrap();
    assert_eq!(x, xd);

    println!(&quot;3**247 is {} and serializes to {}&quot;, x, xs);
}
</code></pre>
<p>Result</p>
<pre><code>3**247 is 7062361041362837614435796717454722507454089864783271756927542774477268334591598635421519542453366332460075473278915787 and serializes to [1,[3323516107,3672165520,4080039719,3245710364,216105283,4292129601,4006727268,340573034,2851604588,3366124224,3797961372,1024846073,179]]
</code></pre>
<p>What about third party crates that are not yet to support the <code>serde</code> feature?
The <code>serde</code> crate provides another approach called <a href="https://serde.rs/remote-derive.html">remote derive</a>. Basically, you create a local copy of the remote type
and then serialize the local type through a bridge. Check out the <a href="https://serde.rs/remote-derive.html">documentation</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="random-numbers"><a class="header" href="#random-numbers">Random numbers</a></h1>
<p>A lot of applications require random numbers. The <a href="https://crates.io/crates/rand"><code>rand</code></a> crate is a very popular library in Rust to generate random numbers. 
It supports a wide variety of random number generators and distributions, each with a different performance and security trade off. 
For more details, you can read the <a href="https://rust-random.github.io/book/intro.html">Rust Rand Book</a>.
To use the <code>rand</code> crate, just do the following in your <code>Cargo.toml</code> file.</p>
<pre><code>[dependencies]
rand = &quot;0.7.3&quot;
</code></pre>
<h2 id="get-a-random-number"><a class="header" href="#get-a-random-number">Get a random number</a></h2>
<p>To get a random number, you can simply do the following.</p>
<pre><pre class="playground"><code class="language-rust editable"><span class="boring">extern crate rand;
</span>
fn main() {
    let i: i32 = rand::random();
    println!(&quot;The random i32 is {}&quot;, i);
}
</code></pre></pre>
<p>The <code>random()</code> is smart enough to know the primitive type it is <strong>supposed</strong> to generate. Check out the example below.</p>
<pre><pre class="playground"><code class="language-rust editable"><span class="boring">extern crate rand;
</span>
fn main() {
    let x: u8 = rand::random();
    println!(&quot;The random u8 is {}&quot;, x);

    let x: f64 = rand::random();
    println!(&quot;The random f64 is {}&quot;, x);

    let x:bool = rand::random();
    println!(&quot;The random bool {}&quot;, x);
}
</code></pre></pre>
<p>What about generating a random number within a range? For that, you need to
create a random number generator and call its <code>gen_range()</code> function.</p>
<pre><pre class="playground"><code class="language-rust editable"><span class="boring">extern crate rand;
</span>
use rand::thread_rng;
use rand::Rng;

fn main() {
    let mut rng = thread_rng();
    let y: f64 = rng.gen_range(-10.0, 10.0);
    println!(&quot;Number from -10. to 10.: {}&quot;, y);
    println!(&quot;Number from 0 to 9: {}&quot;, rng.gen_range(0, 10));
}
</code></pre></pre>
<h2 id="get-a-series-of-random-numbers"><a class="header" href="#get-a-series-of-random-numbers">Get a series of random numbers</a></h2>
<p>In order to get a series of random numbers, you could call the <code>random()</code> function
multiple times. But that is slow since every time it needs to instantiate and seed
a new random number generator. It is faster to create the generator once and 
call its <code>gen()</code> function repeatedly.</p>
<pre><pre class="playground"><code class="language-rust editable"><span class="boring">extern crate rand;
</span>
use rand::thread_rng;
use rand::Rng;

fn main() {
    let mut rng = thread_rng();
    for i in 1..10 {
        println!(&quot;Random number #{}: {}&quot;, i, rng.gen_range(0, 100));
    }
}
</code></pre></pre>
<p>The generator can quickly fill an array with random integers.</p>
<pre><pre class="playground"><code class="language-rust editable"><span class="boring">extern crate rand;
</span>
use rand::thread_rng;
use rand::Rng;

fn main() {
    let mut arr = [0i32; 9];
    thread_rng().try_fill(&amp;mut arr[..]);
    println!(&quot;Random number array {:?}&quot;, arr);
}
</code></pre></pre>
<p>Another neat feature of the generator is that it can generate random numbers 
from a probability distribution.</p>
<pre><pre class="playground"><code class="language-rust editable"><span class="boring">extern crate rand;
</span>
use rand::thread_rng;
use rand::Rng;

fn main() {
    let mut rng = thread_rng();
    let distr = rand::distributions::Uniform::new_inclusive(1, 100);
    let mut nums = [0i32; 3];
    for x in &amp;mut nums {
        *x = rng.sample(distr);
    }
    println!(&quot;Some numbers: {:?}&quot;, nums);
}
</code></pre></pre>
<h2 id="webassembly"><a class="header" href="#webassembly">WebAssembly</a></h2>
<p>Under the hood, the <code>rand</code> crate uses the operating system's native random
functions to seed the random number generator. This initial entropy seed
comes from the hardware noise. However, when Rust programs inside virtual
machines like WebAssembly, it does not have access to native random hardware.</p>
<p>When the <code>rand</code> crate is compiled for WebAssembly, it has a special feature
to use JavaScript's random function to seed the generator. This works when
your WebAssembly application is running inside a JavaScript host, such as in
a web browser or in Node.js. To enable that, do the following in your <code>Cargo.toml</code>.</p>
<pre><code>[dependencies]
rand = { version = &quot;0.7.3&quot;, features = [&quot;wasm-bindgen&quot;] }
</code></pre>
<p>Then you must use one of the <a href="https://rustwasm.github.io/docs/wasm-bindgen/"><code>wasm-bindgen</code></a> compatible tools to instrument 
your Rust code to call external JavaScript and a JavaScript shim to be called 
from Rust.</p>
<ul>
<li>The <a href="https://www.npmjs.com/package/ssvmup"><code>ssvmup</code></a> and <a href="https://www.npmjs.com/package/ssvm"><code>ssvm</code></a> tools enable high performance Rust + JavaScript hybrid applications in Node.js. <a href="https://cloud.secondstate.io/server-side-webassembly/getting-started">Check out this tutorial</a>.</li>
<li>The <a href="https://rustwasm.github.io/wasm-pack/"><code>wasm-pack</code></a> tool can generate Rust and JavaScript code for the V8 engine.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="cryptography-with-openssl"><a class="header" href="#cryptography-with-openssl">Cryptography with openssl</a></h1>
<p><a href="https://www.openssl.org/">OpenSSL</a> is an widely used open source library to perform cryptographic
operations. We can use it to encrypt, decrypt, digest, and sign data, 
as well as to make SSL/TLS secure connections through the Internet.</p>
<p>In this chapter, we will cover the <a href="https://crates.io/crates/openssl"><code>openssl</code></a> crate. 
You can <a href="https://docs.rs/openssl/0.10.29/openssl/">read more documentation about it</a>.</p>
<blockquote>
<p>Since the <code>openssl</code> crate relies on the native operating system's OpenSSL library to perform cryptographic operations, it cannot be compiled into WebAssembly targets.</p>
</blockquote>
<p>Let's <a href="openssl/rsa.html">start with an example</a> to create a pair of RSA keys, and use them to encrypt and decrypt data.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="rsa-public-key-encryption"><a class="header" href="#rsa-public-key-encryption">RSA public key encryption</a></h1>
<p>To use the <code>openssl</code> crate, you just need to add the following dependencies to your <code>Cargo.toml</code> file.</p>
<pre><code>[dependencies]
openssl = &quot;0.10.28&quot;
</code></pre>
<p>The example below generates an RSA public and private key pair, and
encrypts the keys with a passphrase. The outputs are text strings that
can be saved into files. Those files are called PEM (Privacy Enhanced Mail) files.</p>
<pre><pre class="playground"><code class="language-rust editable"><span class="boring">extern crate openssl;
</span>
use openssl::rsa::{Rsa, Padding};
use openssl::symm::Cipher;

fn main() {
    let passphrase = &quot;rust_by_example&quot;;

    let rsa = Rsa::generate(1024).unwrap();
    let private_key: Vec&lt;u8&gt; = rsa.private_key_to_pem_passphrase(Cipher::aes_128_cbc(), passphrase.as_bytes()).unwrap();
    let public_key: Vec&lt;u8&gt; = rsa.public_key_to_pem().unwrap();

    println!(&quot;Private key: {}&quot;, String::from_utf8(private_key).unwrap());
    println!(&quot;Public key: {}&quot;, String::from_utf8(public_key).unwrap());
}
</code></pre></pre>
<p>Next, we can import public and private keys from the PEM document.
In the example, we demonstrate how to encrypt a byte array of data using the
public key. Such encrypted data can only be decrypted by the correspding private key.</p>
<pre><pre class="playground"><code class="language-rust editable"><span class="boring">extern crate openssl;
</span>
use openssl::rsa::{Rsa, Padding};

fn main() {
    let passphrase = &quot;rust_by_example&quot;;
    
    let public_key_pem = &quot;-----BEGIN PUBLIC KEY-----
MIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQDC+Jx89MjzbWw9PPh0dffD+i2c
J7XMioLndImQvQiNJjZ00zyxjgt4+wkual+ZHhH94HIjRIeLI+ncBEjFMa1xIzHT
exz/pvJUCsHNxNK9958zR0E997xxSf3C2Lu8BWtJG348xd5QNzb+R+i963PtcAsQ
fCu+q5gbqqtQEIjlMwIDAQAB
-----END PUBLIC KEY-----&quot;;

    let private_key_pem = &quot;-----BEGIN RSA PRIVATE KEY-----
Proc-Type: 4,ENCRYPTED
DEK-Info: AES-128-CBC,43371B6CECDB096AC2A362FD33BF4B07

aIs3x9UBN95VJJFsd1ddYxmwAKQdFE5BJwZVYtidV+cZ4Qpmg9tdBLm8AhF5bVGR
FzAVMxTEFQgwT4o2jH2UxRkRmChwNy6aqdGteDIK6yXQK7//GMmxhbvqMmFzwdof
2E7Jkq3BQQEqMFu2CxRUPUFYRIebEIZSDCD3PoJ6p7a77qwm/KCXCbad/DqtOGkJ
wOkPH5AXLIu02MJfs+vcLswXFMlq7aaUrAv5WGt1SpKz9Co6bplSYDG7JE+906Uw
MIg4XDJTJDKCKyDaPkMydw6StvyNuZfIYUNIofulLci7yoNEGvwQHsHCaHr6n4bt
I4iC9CbkEcPbf06HAWGFfsexeLGf9mU0HVsZi83QdMhWMbOREakFU755AMvTeB8w
IMCNn55nzJlSHooKuvJAmbqBBb4+wqgwnoYQEVZmTDZxqT/eR08Zl9d1QeKB+1fw
gjZmY/10kFLnTKlWGIaLIu60ehbXxZeFbW+m1pF9uHEiIkWgkrHNjKfzWh5EyfhY
vXxWuZH92ZP/nioGzVQr00oSEPLwW1RSoAx3jPuu1EILNu7lFL896CsDZpa1Oigf
OMxk0GhMuKs4H6TlHmx5a0TOAcGYWEbnqXi+KUw7pMPFiEs1/2crFI6QfQx8R7dL
/ohKFvksPExsB196RZ1PFyMdryOr/mCqI4nBT+KzPz4zJF2iTMGq3NFQI2MvW/4g
WMwsyQtIJQviFJpYlQpOVBFaeB69oHJMxfauM8OdEU8yomFl3sAVagNxPfiWsGt4
LRsReK2BDT/pnhhZG96qSsNPwQlrwffBleTy9BGSuHHox6A7GKyVAAOMND/TY1ak
-----END RSA PRIVATE KEY-----&quot;;

    let data = &quot;A quick brown fox jumps over the lazy dog.&quot;;

    // Encrypt with public key
    let rsa = Rsa::public_key_from_pem(public_key_pem.as_bytes()).unwrap();
    let mut buf: Vec&lt;u8&gt; = vec![0; rsa.size() as usize];
    let _ = rsa.public_encrypt(data.as_bytes(), &amp;mut buf, Padding::PKCS1).unwrap();
    println!(&quot;Encrypted: {:?}&quot;, buf);

    let data = buf;

    // Decrypt with private key
    let rsa = Rsa::private_key_from_pem_passphrase(private_key_pem.as_bytes(), passphrase.as_bytes()).unwrap();
    let mut buf: Vec&lt;u8&gt; = vec![0; rsa.size() as usize];
    let _ = rsa.private_decrypt(&amp;data, &amp;mut buf, Padding::PKCS1).unwrap();
    println!(&quot;Decrypted: {}&quot;, String::from_utf8(buf).unwrap());
}
</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="n-dimensional-array"><a class="header" href="#n-dimensional-array">N-dimensional array</a></h1>
<p>The N-dimensional array is a widely used data structure for scientific 
computing and data analysis. The <a href="https://crates.io/crates/ndarray"><code>ndarray</code></a> crate provides support for
N-dimensional array in Rust. It is widely used by other crates.
To use the <code>ndarray</code> crate, just do the following in your <code>Cargo.toml</code> file.</p>
<pre><code>[dependencies]
ndarray = &quot;0.13.0&quot;
</code></pre>
<h2 id="basic-operations"><a class="header" href="#basic-operations">Basic operations</a></h2>
<p>To create a 3-D array, and access one of its element by index, do the following.
The example creates a 3x4x5 array, and we access its elements using the 
<code>[[i, j, k]]</code> notation, where <code>i j k</code> are index positions for the element.</p>
<pre><pre class="playground"><code class="language-rust editable"><span class="boring">extern crate ndarray;
</span>
use ndarray::Array3;

fn main() {
    let mut a3 = Array3::&lt;f64&gt;::zeros((3, 4, 5));
    a3[[0, 0, 0]] = 0.0;
    a3[[1, 1, 1]] = 1.0;
    a3[[2, 2, 2]] = 2.0;
    println!(&quot;The 3D array is {:?}&quot;, a3);
}
</code></pre></pre>
<p>Here is another example of a 3x3 2D array.</p>
<pre><pre class="playground"><code class="language-rust editable"><span class="boring">extern crate ndarray;
</span>
use ndarray::Array2;

fn main() {
    let mut a2 = Array2::&lt;f64&gt;::zeros((3, 3));
    a2[[0, 0]] = 0.0;
    a2[[0, 1]] = 0.5;
    a2[[0, 2]] = -0.5;
    a2[[1, 0]] = 1.0;
    a2[[1, 1]] = 1.5;
    a2[[1, 2]] = -1.5;
    a2[[2, 0]] = 2.0;
    a2[[2, 1]] = 2.5;
    a2[[2, 2]] = -2.5;
    println!(&quot;The 2D array is {:?}&quot;, a2);
}
</code></pre></pre>
<p>Manually setting array elements by index positions is tedious. Next, let's see a better way to do this.</p>
<h2 id="create-arrays"><a class="header" href="#create-arrays">Create arrays</a></h2>
<p>The <code>arr2</code> and <code>arr3</code> macros allow you to create 2D and 3D arrays quickly.</p>
<p>The example creates a 3x3 2D array.</p>
<ul>
<li>The array has 3 rows <code>[row0, row1, row2]</code>. For example, <code>row0</code> is <code>[1, 2, 3]</code>.</li>
<li>Each row has 3 columns <code>col0, col1, col2</code>. For example, <code>row0 col0</code> is <code>1</code>.</li>
</ul>
<pre><pre class="playground"><code class="language-rust editable"><span class="boring">extern crate ndarray;
</span>
use ndarray::arr2;

fn main() {
    let mut a2 = arr2(&amp;[[1, 2, 3],
                    [4, 5, 6],
                    [7, 8, 9]]);
    a2[[2, 1]] = 10;
    println!(&quot;The 2D array is {:?}&quot;, a2);
}
</code></pre></pre>
<p>The example creates a 3x2x2 3D array. </p>
<ul>
<li>The array has 3 rows <code>[row0, row1, row2]</code>. For example, <code>row0</code> is <code>[[1, 2], [3, 4]]</code>.</li>
<li>Each row has 2 columns <code>[col0, col1]</code>. For example, <code>row0 col0</code> is <code>[1, 2]</code>.</li>
<li>Each column has 2 levels <code>lvl0, lvl1</code>. For example, <code>row0 col0 lvl0</code> is <code>1</code>. </li>
</ul>
<pre><pre class="playground"><code class="language-rust editable"><span class="boring">extern crate ndarray;
</span>
use ndarray::arr3;

fn main() {
    let mut a3 = arr3(&amp;[[[1, 2], [3, 4]],
                    [[5, 6], [7, 8]],
                    [[9, 0], [1, 2]]]);
    a3[[2, 1, 1]] = 10;
    println!(&quot;The 3D array is {:?}&quot;, a3);
}
</code></pre></pre>
<h2 id="iterate-through-the-arrays"><a class="header" href="#iterate-through-the-arrays">Iterate through the arrays</a></h2>
<p>Using the <code>genrows()</code> function, you can flatten the <code>n</code> dimension array into an 
array of rows. Each row contains a simple (one dimension) array of values
along the original array's shortest axis.</p>
<p>Using the <code>outer_iter()</code> function, you can deconstruct the <code>n</code> dimension array 
into a simple (one dimension) array of <code>n-1</code> dimension arrays.</p>
<pre><pre class="playground"><code class="language-rust editable"><span class="boring">extern crate ndarray;
</span>
use ndarray::arr3;

fn main() {
    let a3 = arr3(&amp;[[[1, 2], [3, 4]],
                    [[5, 6], [7, 8]],
                    [[9, 0], [1, 2]]]);
    for row in a3.genrows() {
        // Each row is a 1D array
        println!(&quot;row is {:?}&quot;, row);
    }
    for a2 in a3.outer_iter() {
        println!(&quot;2D array is {:?}&quot;, a2);
    }
}
</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="lazy-static"><a class="header" href="#lazy-static">Lazy static</a></h1>
<p>The <a href="https://docs.rs/lazy_static/1.4.0/lazy_static/"><code>lazy_static</code></a> crate is a simple but widely used macro that allows you to initialize static variables at runtime.
To use it, add the following to your <code>Cargo.toml</code>.</p>
<pre><code>[dependencies]
lazy_static = &quot;1.4.0&quot;
</code></pre>
<p>The example below shows three static variables that must be initialized
by code after the program starts.</p>
<pre><pre class="playground"><code class="language-rust editable">#[macro_use]
<span class="boring">extern crate lazy_static;
</span>
use std::collections::HashMap;

lazy_static! {
    static ref HASHMAP: HashMap&lt;u32, &amp;'static str&gt; = {
        let mut m = HashMap::new();
        m.insert(0, &quot;foo&quot;);
        m.insert(1, &quot;bar&quot;);
        m.insert(2, &quot;baz&quot;);
        m
    };
    static ref COUNT: usize = HASHMAP.len();
    static ref NUMBER: u32 = times_two(21);
}

fn times_two(n: u32) -&gt; u32 { n * 2 }

fn main() {
    println!(&quot;The map has {} entries.&quot;, *COUNT);
    println!(&quot;The entry for `0` is \&quot;{}\&quot;.&quot;, HASHMAP.get(&amp;0).unwrap());
    println!(&quot;A expensive calculation on a static results in: {}.&quot;, *NUMBER);
}
</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="regular-expression"><a class="header" href="#regular-expression">Regular expression</a></h1>
<p>Coming soon!</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="webassembly-1"><a class="header" href="#webassembly-1">WebAssembly</a></h1>
<p>Besides operating system specific native binaries, Rust programs can also be compiled into managed 
code that runs inside containers or virtual machines. The reason to use managed code is runtime safety. That allows un-trusted
Rust programs to run in environments such as web browsers and servers. Compared with native binaries, managed
containers are also much easier to provision, limit access to resources, start, and stop on demand. A popular managed code compiler target is the WebAssembly virtual machine. With WebAssembly, your Rust programs can run side-by-side with Javascript in web browsers and servers.</p>
<p>In this chapter, we will first show you how to <a href="webassembly/compile.html">compile</a> and <a href="(webassembly/run.html">run</a> a very simple Rust function in WebAssembly. The simple example is followed by a <a href="webassembly/browser.html">hello world example</a> running in web browsers.</p>
<p>More complex Rust / WebAssembly examples come from the server-side. We will demonstrate how to <a href="webassembly/nodejs.html">call Rust functions from Node.js</a> Javascript applications, as well as how to <a href="webassembly/nodejshelper.html">access Node.js modules from Rust functions</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="compile-targets-for-webassembly"><a class="header" href="#compile-targets-for-webassembly">Compile targets for WebAssembly</a></h1>
<p>There are several Rust compiler targets for WebAssembly. They differ
because different WebAssembly VMs supports different extensions. 
For example, some WebAssembly VMs have access the WASI extension that allows
access to system resources such as the file system.
The <code>wasm32</code> target is the most general target that produces plain WebAssembly
bytecode that can run on any WebAssembly VM.</p>
<p>To add the <code>wasm32</code> target to the compiler toolchain, do the following on your operating system's command line.</p>
<pre><code>$ rustup target add wasm32-unknown-unknown
$ rustup override set nightly
$ rustup target add wasm32-unknown-unknown --toolchain nightly
</code></pre>
<blockquote>
<p>Check out the <a href="https://github.com/second-state/wasm-learning/tree/master/browser/triple">complete example source code here</a>.</p>
</blockquote>
<p>Now, create a Rust library project in cargo, and create a public function like the following.</p>
<pre><code>#[no_mangle]
pub extern fn triple(x: i32) -&gt; i32 {
  return 3 * x;
}
</code></pre>
<p>You can build the project into WebAssembly bytecode using <code>cargo</code>.</p>
<pre><code>$ cargo +nightly build --target wasm32-unknown-unknown --release
</code></pre>
<p>The compiled WebAssembly bytecode application is a single file with the <code>wasm</code> extension. For example, here is the <code>wasm</code> file from our example <code>target/wasm32-unknown-unknown/release/my_project_name.wasm</code>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="run-a-simple-webassembly-program"><a class="header" href="#run-a-simple-webassembly-program">Run a simple WebAssembly program</a></h1>
<p>In the previous article, we showed you how to compile a Rust program
into a WebAssembly bytecode file.
The easiest way to run a WebAssembly bytecode file is to simply load
it into a web browser. Most modern web browsers already support
WebAssembly.</p>
<p>The code example below shows how to create a WebAssembly VM, load the 
bytecode application, export the Rust function in the bytecode into Javascript,
and then call this Rust / WebAssembly function from Javascript.
All those steps could be done in the browser's Javascript console.</p>
<pre><code>const response = await fetch('my_project_name.wasm');
const buffer = await response.arrayBuffer();
const module = await WebAssembly.compile(buffer);
const instance = await WebAssembly.instantiate(module);
const exports = instance.exports;
const triple = exports.triple;
</code></pre>
<p>In the browser Javascript console, you can now call the Rust <code>triple()</code> function
in WebAssembly and triple your input number. The code below returns number <code>30</code>.</p>
<pre><code>triple(10);
</code></pre>
<p>Of course, you can just easily load Rust compiled WebAssembly functions from
your web page. Check out <a href="https://github.com/second-state/wasm-learning/tree/master/browser/triple">a full example here</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="rust-javascript-binding-through-webassembly"><a class="header" href="#rust-javascript-binding-through-webassembly">Rust Javascript binding through WebAssembly</a></h1>
<p>In the previous articles, we showed how to compile a Rust function into
WebAssembly, and then call this function from Javascript in a web browser.
However, that approach has some severe limitations. Specifically, WebAssembly
has very limited support for data types. When a WebAssembly function is 
exported to Javascript, the input parameters and return values are limited
32 bit integers. You cannot even pass or return string values to the WebAssembly
function! You could even do a Hello World!</p>
<p>Fortunately, the <code>wasm-bindgen</code> project provides binding between Rust and
Javascript. An easy way to <code>wasm-bindgen</code> in a browser project is to the 
<code>wasm-pack</code> tool. Here is how to install <code>wasm-pack</code> through the npm package manager.</p>
<pre><code>$ npm install -g wasm-pack
</code></pre>
<p>In your project's <code>Cargo.toml</code>, add dependency for the <code>wasm-bindgen</code> crate.</p>
<pre><code>[dependencies]
wasm-bindgen = &quot;0.2.50&quot;
</code></pre>
<p>Below is a Rust library function we wrote. As you can see it now takes and returns <code>String</code> values. The function must be annotated with <code>#[wasm_bindgen]</code> in order for the Rust compiler toolchain to call <code>wasm-bindgen</code> to generate the necessary shim code that binds Rust and Javascript through WebAssembly.</p>
<pre><code>use wasm_bindgen::prelude::*;

#[wasm_bindgen]
pub fn say(s: String) -&gt; String {
  let r = String::from(&quot;hello &quot;);
  return r + &amp;s;
}
</code></pre>
<p>Build the <code>wasm</code> bytecode application and its Javascript helper files via <code>wasm-pack</code>.
The generated files are in the <code>pkg</code> directory.</p>
<pre><code>$ wasm-pack build --target web
</code></pre>
<p>From a web browser's Javascript console, you can load the generated Javascript file, export the Rust function, and call it.</p>
<pre><code>import init, { say } from 'pkg/hello_lib.js';
init();
say(&quot;Michael&quot;);
</code></pre>
<p>The result is <code>Hello Michael</code>.</p>
<p>To see the complete source code and run it on a web page, <a href="https://github.com/second-state/wasm-learning/tree/master/browser/hello">checkout here</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="rust-and-webassembly-on-the-server-side"><a class="header" href="#rust-and-webassembly-on-the-server-side">Rust and WebAssembly on the server side</a></h1>
<p>In the previous article, we discussed how to run Rust functions in web browsers.
In this article, we will show you how to do this on the server side.
We believe that Rust and WebAssembly <a href="https://cloud.secondstate.io/server-side-webassembly/why">brings a lot of benefits</a> to server side
applications.</p>
<p>On the server side, we use the open source <a href="https://github.com/second-state/SSVM">Second State VM (SSVM)</a> to execute
Rust and WebAssembly functions in the Node.js environment. We still use
the <code>wasm-bindgen</code> crate to support binding between Rust and
Javascript. An easy way to <code>wasm-bindgen</code> in a SSVM Node.js project is to the 
<code>ssvmup</code> tool. Here is how to install <code>ssvmup</code> through the npm package manager.</p>
<pre><code>$ npm install -g ssvmup
</code></pre>
<p>In your project's <code>Cargo.toml</code>, add dependency for the <code>wasm-bindgen</code> crate.</p>
<pre><code>[dependencies]
wasm-bindgen = &quot;=0.2.61&quot;
</code></pre>
<h2 id="hello-world"><a class="header" href="#hello-world">Hello world</a></h2>
<p>Below is a Rust hello world function we wrote. The function must be annotated with <code>#[wasm_bindgen]</code> in order for the Rust compiler toolchain to call <code>wasm-bindgen</code> to generate the necessary shim code that binds Rust and Javascript through WebAssembly.</p>
<pre><code>use wasm_bindgen::prelude::*;

#[wasm_bindgen]
pub fn say(s: String) -&gt; String {
  let r = String::from(&quot;hello &quot;);
  return r + &amp;s;
}
</code></pre>
<p>Build the <code>wasm</code> bytecode application and its Javascript helper files via <code>ssvmup</code>.
The generated files are in the <code>pkg</code> directory.</p>
<pre><code>$ ssvmup build
</code></pre>
<p>In a Javascript application, you can load the generated Javascript file, export the Rust function, and call it.</p>
<pre><code>const { say } = require('pkg/hello_lib.js');
say(&quot;Michael&quot;);
</code></pre>
<p>You can now run the Javascript application from Node.js command line.</p>
<pre><code>$ node app.js
Hello Michael
</code></pre>
<blockquote>
<p>To see the complete source code and run it in a Node.js server, <a href="https://github.com/second-state/wasm-learning/tree/master/nodejs/hello">checkout here</a>.</p>
</blockquote>
<h2 id="beyond-simple-arguments"><a class="header" href="#beyond-simple-arguments">Beyond simple arguments</a></h2>
<p>Using the <code>serde</code> crate, we can pass in and return arbitary Javascript values to/from Rust functions. The idea is to serialize the entire set of call arguments, and return values, into JSON strings. First, add <code>serde</code> to your dependencies.</p>
<pre><code>[dependencies]
serde = { version = &quot;1.0&quot;, features = [&quot;derive&quot;] }
serde_json = &quot;1.0&quot;
wasm-bindgen = &quot;=0.2.61&quot;
</code></pre>
<p>The Rust function takes two floating point numbers, and returns the product of
the two. Notice that the input and return values are all encoded in JSON.</p>
<pre><code>use wasm_bindgen::prelude::*;

#[wasm_bindgen]
pub fn area(sides: &amp;str) -&gt; String {
  let s: (f32, f32) = serde_json::from_str(&amp;sides).unwrap();
  let a = s.0 * s.1;
  return serde_json::to_string(&amp;a).unwrap();
}
</code></pre>
<p>Build and create the <code>pkg</code> folder for the compiled <code>wasm</code> bytecode file and the Javascript shim file <code>my_project_name.js</code>.</p>
<pre><code>$ ssvmup build
</code></pre>
<p>The Javascript calling program in Node.js looks like the following.</p>
<pre><code>const { area } = require('pkg/my_project_name.js');
var x = [10., 5.];
console.log( area(JSON.stringify(x)) );
</code></pre>
<p>Run the Node.js app shows the following result.</p>
<pre><code>$ node app.js
50.0
</code></pre>
<blockquote>
<p>To see the complete source code and run it in Node.js, <a href="https://github.com/second-state/wasm-learning/tree/master/nodejs/json_io">checkout here</a>.</p>
</blockquote>
<h2 id="structs-and-objects"><a class="header" href="#structs-and-objects">Structs and objects</a></h2>
<p>Using the <code>serde</code> crate, we can pass in complex Javascript objects and arrays to Rust functions, and return Javascript objects. Javascript objects are mapped to Rust structs, and arrays are mapped to Rust tuples.</p>
<p>The Rust function <code>draw()</code> takes two JSON strings, each representing a <code>Point</code> struct, and returns a JSON string representing a <code>Line</code> struct.</p>
<pre><code>use wasm_bindgen::prelude::*;
use serde::{Serialize, Deserialize};

#[derive(Serialize, Deserialize, Debug)]
struct Point {
  x: f32,
  y: f32
}

#[derive(Serialize, Deserialize, Debug)]
struct Line {
  points: Vec&lt;Point&gt;,
  valid: bool,
  length: f32,
  desc: String
}

#[wasm_bindgen]
pub fn draw(points: &amp;str) -&gt; String {
  let ps: (Point, Point, String) = serde_json::from_str(&amp;points).unwrap();
  let length = ((ps.0.x - ps.1.x) * (ps.0.x - ps.1.x) + (ps.0.y - ps.1.y) * (ps.0.y - ps.1.y)).sqrt();

  let valid = if length == 0.0 { false } else { true };
  let line = Line { points: vec![ps.0, ps.1], valid: valid, length: length, desc: ps.2 };
  return serde_json::to_string(&amp;line).unwrap();
}
</code></pre>
<p>Build and create the <code>pkg</code> folder for the compiled <code>wasm</code> bytecode file and the Javascript shim file <code>my_project_name.js</code>.</p>
<pre><code>$ ssvmup build
</code></pre>
<p>The Javascript calling program in Node.js looks like the following.</p>
<pre><code>const { draw } = require('pkg/my_project_name.js');
var x = [{x:1.5, y:3.8}, {x:2.5, y:5.8}, &quot;A thin red line&quot;];
console.log( draw(JSON.stringify(x)) );
</code></pre>
<p>Run the Node.js app shows the following result.</p>
<pre><code>$ node app.js
{&quot;points&quot;:[{&quot;x&quot;:1.5,&quot;y&quot;:3.8},{&quot;x&quot;:2.5,&quot;y&quot;:5.8}],&quot;valid&quot;:true,&quot;length&quot;:2.2360682,&quot;desc&quot;:&quot;A thin red line&quot;}
</code></pre>
<blockquote>
<p>To see the complete source code and run it in Node.js, <a href="https://github.com/second-state/wasm-learning/tree/master/nodejs/json_io">checkout here</a>.</p>
</blockquote>
<h2 id="binary-data"><a class="header" href="#binary-data">Binary data</a></h2>
<p>A server side function often needs to process binary data directly. The SSVM
toolchain supports that use case out of the box.
In this example, we will show you how to create a Rust function on the server
to compute a SHA3 cryptographic digest for an arbitary input binary data array. First, add 
the <code>sh3</code> crate as a dependency.</p>
<pre><code>[dependencies]
sha3 = &quot;0.8.2&quot;
wasm-bindgen = &quot;=0.2.61&quot;
</code></pre>
<p>Below is the Rust function that computes the SHA3 digest value. Notice that both
its input and return values are byte arrays.</p>
<pre><code>use wasm_bindgen::prelude::*;
use sha3::{Digest, Sha3_256};

#[wasm_bindgen]
pub fn sha3_digest(v: &amp;[u8]) -&gt; Vec&lt;u8&gt; {
  return Sha3_256::digest(&amp;v).as_slice().to_vec();
}
</code></pre>
<p>Build and create the <code>pkg</code> folder for the compiled <code>wasm</code> bytecode file and the Javascript shim file <code>my_project_name.js</code>.</p>
<pre><code>$ ssvmup build
</code></pre>
<p>The Javascript calling program in Node.js looks like the following.</p>
<pre><code>const { sha3_digest } = require('pkg/my_project_name.js');
console.log( sha3_digest(encoder.encode(&quot;This is an important message&quot;)) );
</code></pre>
<p>Run the Node.js app shows the following result.</p>
<pre><code>$ node app.js
000000  57 1b e7 d1 bd 69 fb 31 9f 0a d3 fa 0f 9f 9a b5  W.çÑ½iû1..Óú...µ
000010  2b da 1a 8d 38 c7 19 2d 3c 0a 14 a3 36 d3 c3 cb  +Ú..8Ç.-&lt;..£6ÓÃË
</code></pre>
<blockquote>
<p>To see the complete source code and run it in Node.js, <a href="https://github.com/second-state/wasm-learning/tree/master/nodejs/functions">checkout here</a>.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="call-javascript-from-rust"><a class="header" href="#call-javascript-from-rust">Call Javascript from Rust</a></h1>
<p>In the previous article, we discussed how to call Rust functions from
Javascript. How about the other way around? The <code>nodejs-helper</code> crate
enables Rust functions to call Javascript functions in Node.js.</p>
<blockquote>
<p>To see the complete source code and run it in Node.js, <a href="https://github.com/second-state/wasm-learning/tree/master/nodejs/nodejs_example">checkout here</a>.</p>
</blockquote>
<p>In your project's <code>Cargo.toml</code>, add dependency for the <a href="https://github.com/second-state/nodejs-helper"><code>nodejs-helper</code></a> and <code>wasm-bindgen</code> crates.</p>
<pre><code>[dependencies]
wasm-bindgen = &quot;=0.2.61&quot;
nodejs-helper = &quot;0.0.3&quot;
</code></pre>
<h2 id="console-and-time"><a class="header" href="#console-and-time">Console and time</a></h2>
<p>Recall that WebAssembly is a very simple and standalone virtual machine. It
has no access the operating system's standard input / output, as well as 
features such as the system clock. In our Rust function, we can
rely on the Javascript functions in Node.js to access those festures.</p>
<pre><code>use wasm_bindgen::prelude::*;

#[wasm_bindgen]
pub fn show_now() {
  nodejs_helper::console::log(&quot;Timestamp now: &quot;);
  nodejs_helper::console::log(&amp;nodejs_helper::date::timestamp());
}

#[wasm_bindgen]
pub fn utc_now() {
  nodejs_helper::console::log(&quot;UTC time: &quot;);
  nodejs_helper::console::log(&amp;nodejs_helper::date::utc_string());
}

#[wasm_bindgen]
pub fn my_time(tz: &amp;str) {
  nodejs_helper::console::log(tz);
  nodejs_helper::console::log(&amp;nodejs_helper::date::format_date(&quot;en-US&quot;, &quot;long&quot;, &quot;numeric&quot;, &quot;long&quot;, &quot;numeric&quot;, tz, &quot;short&quot;));
}
</code></pre>
<p>Build the <code>wasm</code> bytecode application and its Javascript helper files via <code>ssvmup</code>.
The generated files are in the <code>pkg</code> directory.</p>
<pre><code>$ ssvmup build
</code></pre>
<p>In a Javascript application, you can load the generated Javascript file, export the Rust function, and call it.</p>
<pre><code>const { show_now, utc_now, my_time } = require('pkg/nodejs_example.js');

show_now();
utc_now();
my_time(&quot;America/Chicago&quot;);
</code></pre>
<p>You can now run the Javascript application from Node.js command line.</p>
<pre><code>$ node date.js
Timestamp now:
1588013800826
UTC time:
Mon, 27 Apr 2020 18:56:40 GMT
America/Chicago
Monday, April 27, 2020, CDT
</code></pre>
<h2 id="file-system-access"><a class="header" href="#file-system-access">File system access</a></h2>
<p>The Rust functions in this section read an image file from the local file system, resize it, and write back to the file system. It also uses the Javascript console tool to measure the time spent on each task.</p>
<pre><code>[dependencies]
serde = { version = &quot;1.0&quot;, features = [&quot;derive&quot;] }
serde_json = &quot;1.0&quot;
wasm-bindgen = &quot;=0.2.61&quot;
image = &quot;0.23.0&quot;
</code></pre>
<p>The Rust function takes
a JSON string input that contains the image file names and resized dimensions.</p>
<pre><code>use wasm_bindgen::prelude::*;

#[derive(Serialize, Deserialize)]
#[derive(Copy, Clone, Debug)]
pub struct Dimension {
  pub width: u32,
  pub height: u32,
}

#[derive(Serialize, Deserialize)]
pub struct Picture {
  pub dim: Dimension,
  pub raw: Vec&lt;u8&gt;,
}

#[wasm_bindgen]
pub fn resize_file(input: &amp;str) {
  // Use JSON to pass multiple call arguments
  let p: (Dimension, String, String) = serde_json::from_str(input).unwrap();

  nodejs_helper::console::time(&quot;Resize file&quot;);
  let raw = nodejs_helper::fs::read_file_sync(&amp;p.1);
  nodejs_helper::console::time_log(&quot;Resize file&quot;, &quot;Done reading&quot;);
  let src = Picture {
    dim: p.0,
    raw: raw,
  };
  let target = resize_impl(&amp;src);
  nodejs_helper::console::time_log(&quot;Resize file&quot;, &quot;Done resizing&quot;);

  nodejs_helper::fs::write_file_sync(&amp;p.2, &amp;target.raw);
  nodejs_helper::console::time_log(&quot;Resize file&quot;, &quot;Done writing&quot;);
  nodejs_helper::console::time_end(&quot;Resize file&quot;);
}

pub fn resize_impl(src: &amp;Picture) -&gt; Picture {
  // ... use the img crate to resize ...
}
</code></pre>
<p>Build and create the <code>pkg</code> folder for the compiled <code>wasm</code> bytecode file and the Javascript shim file <code>my_project_name.js</code>.</p>
<pre><code>$ ssvmup build
</code></pre>
<p>The Javascript calling program in Node.js looks like the following.</p>
<pre><code>const { resize_file } = require('../pkg/nodejs_example.js');

const dim = {
    width: 100,
    height: 100
};

resize_file(JSON.stringify([dim, 'cat.png', `test.png`]));
</code></pre>
<p>Run the Node.js app shows the following result.</p>
<pre><code>$ node image.js
Resize file: 5.603ms Done reading
Resize file: 1506.694ms Done resizing
Resize file: 1507.634ms Done writing
Resize file: 1507.977ms
</code></pre>
<h2 id="sqlite-database-access"><a class="header" href="#sqlite-database-access">Sqlite database access</a></h2>
<p>First, you must have the <code>better-sqlite3</code> module installed in
your Node.js setup. The Rust function will access a sqlite database through this module.</p>
<pre><code>$ npm i better-sqlite3
</code></pre>
<p>The Rust functions to create, update, and query a Sqlite database on the local
file system are as follows.</p>
<pre><code>use wasm_bindgen::prelude::*;
use serde::{Serialize, Deserialize};

#[derive(Serialize, Deserialize)]
pub struct User {
  pub id: u32,
  pub full_name: String,
  pub created: String,
}

#[wasm_bindgen]
pub fn create_sqlite(path: &amp;str) {
  let sql_create = &quot;
CREATE TABLE users (
  id INTEGER PRIMARY KEY NOT NULL,
  full_name TEXT NOT NULL,
  created DATE NOT NULL
);&quot;;
  let sql_insert = &quot;
INSERT INTO users
VALUES
(1, 'Bob McFett', '32-01-01'),
(2, 'Angus Vader', '02-03-04'),
(3, 'Imperator Colin', '01-01-01');&quot;;

  nodejs_helper::sqlite3::create(path);
  nodejs_helper::sqlite3::update(path, sql_create);
  nodejs_helper::sqlite3::update(path, sql_insert);
}

#[wasm_bindgen]
pub fn query_sqlite(path: &amp;str) {
  let sql_query = &quot;SELECT * FROM users;&quot;;
  let rows: String = nodejs_helper::sqlite3::query(path, sql_query);
  let users: Vec&lt;User&gt; = serde_json::from_str(&amp;rows).unwrap();
  for user in users.into_iter() {
    nodejs_helper::console::log(&amp;(user.id.to_string() + &quot; : &quot; + &amp;user.full_name));
  }
}
</code></pre>
<p>Build and create the <code>pkg</code> folder for the compiled <code>wasm</code> bytecode file and the Javascript shim file <code>my_project_name.js</code>.</p>
<pre><code>$ ssvmup build
</code></pre>
<p>The Javascript calling program in Node.js looks like the following.</p>
<pre><code>const { create_sqlite, query_sqlite } = require('pkg/nodejs_example.js');
create_sqlite(&quot;test.sqlite&quot;);
query_sqlite(&quot;test.sqlite&quot;);
</code></pre>
<p>Run the Node.js app shows the following result.</p>
<pre><code>$ node db.js
1 : Bob McFett
2 : Angus Vader
3 : Imperator Colin
</code></pre>
<h2 id="http-request"><a class="header" href="#http-request">HTTP request</a></h2>
<p>First, you must have the <code>sync-request</code> module installed in
your Node.js setup. The Rust function will make synchronous HTTP requests through this module.</p>
<pre><code>$ npm i sync-request
</code></pre>
<p>The Rust functions to access web services via HTTP/HTTPS and then save content on the local file system are as follows.</p>
<pre><code>use wasm_bindgen::prelude::*;

#[wasm_bindgen]
pub fn fetch(url: &amp;str) {
  let content = nodejs_helper::request::fetch_as_string(url);
  nodejs_helper::console::log(url);
  nodejs_helper::console::log(&amp;content);
}

#[wasm_bindgen]
pub fn download(url: &amp;str, path: &amp;str) {
  let content = nodejs_helper::request::fetch(url);
  nodejs_helper::fs::write_file_sync(path, &amp;content);
}
</code></pre>
<p>Build and create the <code>pkg</code> folder for the compiled <code>wasm</code> bytecode file and the Javascript shim file <code>my_project_name.js</code>.</p>
<pre><code>$ ssvmup build
</code></pre>
<p>The Javascript calling program in Node.js looks like the following.</p>
<pre><code>const { fetch, download } = require('../pkg/nodejs_example.js');

fetch(&quot;https://raw.githubusercontent.com/second-state/nodejs-helper/master/LICENSE&quot;);
download(&quot;https://www.secondstate.io/&quot;, &quot;test.html&quot;);
</code></pre>
<p>Run the Node.js app shows the following result.</p>
<pre><code>$ node http.js
https://raw.githubusercontent.com/second-state/nodejs-helper/master/LICENSE
MIT License

Copyright (c) 2020 Second State

Permission is hereby granted, free of charge, to any person obtaining a copy
... ...
</code></pre>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
            </nav>

        </div>

        <!-- Google Analytics Tag -->
        <script type="text/javascript">
            var localAddrs = ["localhost", "127.0.0.1", ""];

            // make sure we don't activate google analytics if the developer is
            // inspecting the book locally...
            if (localAddrs.indexOf(document.location.hostname) === -1) {
                (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
                (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
                m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
                })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

                ga('create', 'UA-137134458-10', 'auto');
                ga('send', 'pageview');
            }
        </script>
        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        <script src="ace.js" type="text/javascript" charset="utf-8"></script>
        <script src="editor.js" type="text/javascript" charset="utf-8"></script>
        <script src="mode-rust.js" type="text/javascript" charset="utf-8"></script>
        <script src="theme-dawn.js" type="text/javascript" charset="utf-8"></script>
        <script src="theme-tomorrow_night.js" type="text/javascript" charset="utf-8"></script>
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
    </body>
</html>
